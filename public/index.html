<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <title>Chat seguro</title>

    <!-- Viewport para responsive -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" href="/favicon.ico" />
    <link rel="manifest" href="/site.webmanifest">

    <link rel="stylesheet" href="/style.css">


</head>

<body>
    <div class="chat-wrapper">
        <header>
            <h2>
                <span class="logo">E2</span>
                Chat An√≥nimo
            </h2>

            <div id="estado">Conectando...</div>
            <button id="btnLogout" class="logout-btn" type="button" aria-label="Cerrar sesi√≥n">
                Log out
            </button>

            <button id="btnTheme" class="theme-btn" type="button" aria-label="Cambiar modo oscuro" title="Modo oscuro">
                <span class="theme-icon" aria-hidden="true">‚òæ</span>
            </button>

        </header>

        <div class="chat-body">
            <!-- Barra de clave de cifrado -->
            <div id="login">
                <label>Contrase√±a cifrado (no se env√≠a al servidor):</label>
                <input id="claveCifrado" placeholder="Secreta compartida" type="password" />
                <button id="btnClave">Usar clave</button>
                <span id="mensajeLogin"></span>
            </div>

            <!-- Lista de mensajes -->
            <ul id="mensajes"></ul>

            <!-- Formulario de env√≠o -->
            <div id="formulario">
                <input id="input" autocomplete="off" placeholder="Escribe un mensaje..." disabled />
                <input id="fileInput" type="file" accept="image/png,image/jpeg" class="oculto" />
                <button id="btnImagen" class="icon-btn" type="button" disabled title="Adjuntar imagen"
                    aria-label="Adjuntar imagen">
                    <span class="icon">üìé</span>
                </button>
                <button id="btn" disabled>
                    <span class="icon">‚û§</span>
                </button>
            </div>
            <div id="estadoSubida" class="upload-hint"></div>
        </div>
    </div>

    <!-- Cliente de Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        const input = document.getElementById("input");
        const btn = document.getElementById("btn");
        const lista = document.getElementById("mensajes");
        const fileInput = document.getElementById("fileInput");
        const btnImagen = document.getElementById("btnImagen");
        const estadoSubida = document.getElementById("estadoSubida");

        const claveCifradoInput = document.getElementById("claveCifrado");
        const btnClave = document.getElementById("btnClave");
        const mensajeLogin = document.getElementById("mensajeLogin");
        const estado = document.getElementById("estado");

        // Bot√≥n logout (si existe en el HTML)
        const btnLogout = document.getElementById("btnLogout");

        // Bot√≥n de modo oscuro (si existe en el HTML)
        const themeBtn = document.getElementById("btnTheme");

        // Si existe logout, movemos el bot√≥n de tema a la izquierda autom√°ticamente
        if (btnLogout && themeBtn) themeBtn.classList.add("theme-has-logout");

        let cryptoKey = null; // clave derivada de la contrase√±a de cifrado
        let miAutorId = null; // ID an√≥nimo que asigna el servidor a este cliente
        let ultimoAutor = null; // para agrupar mensajes consecutivos de la misma persona
        let bufferMensajesPendientes = []; // mensajes recibidos antes de tener la clave
        let claveValidaIngresada = false; // indica si ya se ingreso la clave permitida
        const mensajesRenderizados = new Map(); // cache por id para reacciones

        const CLAVE_UNICA = "Linux";
        const PASS_STORAGE_KEY = "chatE2E_pass_v1";
        const MAX_UPLOAD_BYTES = 10 * 1024 * 1024; // 10MB
        const MIME_PERMITIDOS = ["image/png", "image/jpeg"];
        const EMOJIS_REACCIONES = ["‚ù§Ô∏è", "üëç", "üòÇ", "üòÆ", "üôè", "üî•"];
        const EMOJI_POR_DEFECTO = "‚ù§Ô∏è";
        const PICKER_DELAY_MS = 420;

        // Por defecto, ocultar logout hasta estar autenticado
        if (btnLogout) btnLogout.style.display = "none";

        function guardarPass(password) {
            try {
                localStorage.setItem(PASS_STORAGE_KEY, password);
            } catch (e) {
                console.warn("No se pudo guardar la contrase√±a localmente:", e);
            }
        }

        function cargarPass() {
            try {
                return localStorage.getItem(PASS_STORAGE_KEY);
            } catch (e) {
                console.warn("No se pudo leer la contrase√±a guardada:", e);
                return null;
            }
        }

        // ---------- UTILIDADES DE CIFRADO ----------

        function strToUint8Array(str) {
            return new TextEncoder().encode(str);
        }

        function uint8ArrayToBase64(bytes) {
            let binary = "";
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToUint8Array(base64) {
            const binary = atob(base64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        async function deriveKeyFromPassword(password) {
            const pwdBytes = strToUint8Array(password);
            const salt = strToUint8Array("SALT-FIJO-DEL-CHAT-EXPERIMENTAL");

            const baseKey = await crypto.subtle.importKey(
                "raw",
                pwdBytes,
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );

            const key = await crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                baseKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );

            return key;
        }

        async function encryptText(plainText) {
            if (!cryptoKey) throw new Error("No hay clave de cifrado");

            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encoded = strToUint8Array(plainText);

            const cipherBuffer = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                cryptoKey,
                encoded
            );

            const cipherBytes = new Uint8Array(cipherBuffer);

            return {
                cipherTextBase64: uint8ArrayToBase64(cipherBytes),
                ivBase64: uint8ArrayToBase64(iv),
            };
        }

        async function decryptText(cipherTextBase64, ivBase64) {
            if (!cryptoKey) throw new Error("No hay clave de cifrado");

            const cipherBytes = base64ToUint8Array(cipherTextBase64);
            const iv = base64ToUint8Array(ivBase64);

            const plainBuffer = await crypto.subtle.decrypt(
                { name: "AES-GCM", iv },
                cryptoKey,
                cipherBytes
            );

            const plainText = new TextDecoder().decode(new Uint8Array(plainBuffer));
            return plainText;
        }

        // ---------- UI MENSAJES ----------
        const reactionPicker = document.createElement("div");
        reactionPicker.className = "reaction-picker oculto";
        EMOJIS_REACCIONES.forEach((emoji) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = emoji;
            btn.addEventListener("click", (e) => {
                e.stopPropagation();
                if (!reactionPicker.dataset.mid) return;
                toggleReaccion(reactionPicker.dataset.mid, emoji);
                cerrarPicker();
            });
            reactionPicker.appendChild(btn);
        });
        document.body.appendChild(reactionPicker);

        function cerrarPicker() {
            reactionPicker.classList.add("oculto");
            reactionPicker.dataset.mid = "";
        }

        function abrirPicker(mensajeId, anchorEl) {
            if (!mensajeId) return;
            reactionPicker.dataset.mid = mensajeId;
            reactionPicker.classList.remove("oculto");
            const rect = anchorEl.getBoundingClientRect();
            const top = rect.top + window.scrollY - 56;
            const left = rect.left + window.scrollX + rect.width / 2 - reactionPicker.offsetWidth / 2;
            reactionPicker.style.top = `${top}px`;
            reactionPicker.style.left = `${left}px`;
        }

        document.addEventListener("click", (e) => {
            if (reactionPicker.classList.contains("oculto")) return;
            if (reactionPicker.contains(e.target)) return;
            cerrarPicker();
        });
        function asegurarReacciones(obj) {
            if (!obj) return {};
            if (obj.reacciones && typeof obj.reacciones === "object") return obj.reacciones;
            return {};
        }

        function registrarMensaje(data) {
            const id = data.id || data.messageId || data._id;
            if (!id) return null;
            const existente = mensajesRenderizados.get(id);
            const reacciones =
                data.reacciones && typeof data.reacciones === "object"
                    ? data.reacciones
                    : existente?.reacciones || {};
            const normalizado = {
                ...existente,
                ...data,
                id,
                messageId: data.messageId || id,
                reacciones,
            };
            mensajesRenderizados.set(id, normalizado);
            return normalizado;
        }

        function crearContenedorMensaje(data) {
            const li = document.createElement("li");
            li.classList.add("mensaje");

            const mid = data.id || data.messageId || data._id;
            if (mid) li.dataset.mid = mid;

            if (data.autor !== ultimoAutor) {
                li.classList.add("nuevo-grupo");
                ultimoAutor = data.autor;
            }

            if (miAutorId && data.autor === miAutorId) {
                li.classList.add("mio");
            } else {
                li.classList.add("otro");
            }

            // Long press en el mensaje para abrir picker
            if (mid) {
                let holdTimer = null;
                let longPress = false;
                const clearTimer = () => {
                    if (holdTimer) {
                        clearTimeout(holdTimer);
                        holdTimer = null;
                    }
                };
                li.addEventListener("pointerdown", (e) => {
                    if (e.target.closest("button")) return;
                    longPress = false;
                    holdTimer = setTimeout(() => {
                        longPress = true;
                        abrirPicker(mid, li);
                    }, PICKER_DELAY_MS);
                });
                li.addEventListener("pointerup", () => {
                    const fue = longPress;
                    clearTimer();
                    if (fue) return;
                    // No hacemos nada en tap corto para no mostrar corazones
                });
                li.addEventListener("pointerleave", clearTimer);
            }

            return li;
        }

        function toggleReaccion(mensajeId, emoji) {
            if (!mensajeId || !emoji) return;
            if (!claveValidaIngresada) return;
            socket.emit("reaccion", { mensajeId, emoji });
        }

        function renderReacciones(li, data) {
            const mensajeId = data.id || data.messageId || data._id;
            if (!mensajeId) return;

            const existente = li.querySelector(".reacciones");
            if (existente) existente.remove();

            const reacciones = asegurarReacciones(data);
            const chips = Object.entries(reacciones).filter(
                ([, autores]) => Array.isArray(autores) && autores.length
            );

            // Si no hay reacciones, no mostramos barra
            if (!chips.length) return;

            const bar = document.createElement("div");
            bar.className = "reacciones";

            const list = document.createElement("div");
            list.className = "reacciones-list";

            chips.forEach(([emoji, autores]) => {
                const usuarios = Array.isArray(autores) ? autores : [];
                const chip = document.createElement("button");
                chip.type = "button";
                chip.className = "reaction-chip";
                chip.dataset.emoji = emoji;
                if (miAutorId && usuarios.includes(miAutorId)) chip.classList.add("mine");
                chip.textContent = `${emoji} ${usuarios.length}`;
                chip.addEventListener("click", (e) => {
                    e.stopPropagation();
                    toggleReaccion(mensajeId, emoji);
                });
                list.appendChild(chip);
            });
            bar.appendChild(list);
            li.appendChild(bar);
        }

        function agregarMensajeTexto(data) {
            const li = crearContenedorMensaje(data);
            li.innerHTML = `
      <div class="texto">${data.texto}</div>
      <div class="hora">${data.fecha || ""}</div>
    `;
            renderReacciones(li, data);
            lista.appendChild(li);
            lista.scrollTop = lista.scrollHeight;
        }

        function agregarMensajeImagen(data) {
            const li = crearContenedorMensaje(data);
            const bubble = document.createElement("div");
            bubble.className = "imagen-bubble";

            const link = document.createElement("a");
            link.href = data.urlFull;
            link.target = "_blank";
            link.rel = "noopener";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = data.urlThumb || data.urlFull;
            img.alt = data.nombreOriginal || "Imagen compartida";
            img.className = "imagen-thumb";
            link.appendChild(img);

            const meta = document.createElement("div");
            meta.className = "imagen-meta";

            const titulo = document.createElement("span");
            titulo.textContent = data.nombreOriginal || "Imagen";

            const descarga = document.createElement("a");
            descarga.className = "download-chip";
            descarga.href = data.urlFull;
            descarga.download = data.nombreOriginal || "imagen";
            descarga.textContent = "Descargar";

            const hora = document.createElement("span");
            hora.className = "hora";
            hora.textContent = data.fecha || "";

            meta.appendChild(titulo);
            meta.appendChild(descarga);

            bubble.appendChild(link);
            bubble.appendChild(meta);
            bubble.appendChild(hora);

            li.appendChild(bubble);
            renderReacciones(li, data);
            lista.appendChild(li);
            lista.scrollTop = lista.scrollHeight;
        }

        async function procesarBufferSiClaveLista() {
            if (!cryptoKey || !claveValidaIngresada) return;
            if (bufferMensajesPendientes.length === 0) return;

            const pendientes = bufferMensajesPendientes;
            bufferMensajesPendientes = [];

            for (const m of pendientes) {
                const tipo = m.tipo || (m.cipherText ? "texto" : "imagen");
                const messageId = m.id || m.messageId || m._id;
                const baseMensaje =
                    registrarMensaje({
                        ...m,
                        id: messageId,
                        messageId: m.messageId || messageId,
                        reacciones: asegurarReacciones(m),
                    }) || m;

                if (tipo === "imagen") {
                    agregarMensajeImagen(baseMensaje);
                    continue;
                }

                if (!cryptoKey) {
                    bufferMensajesPendientes.push(m);
                    continue;
                }

                try {
                    const texto = await decryptText(m.cipherText, m.iv);
                    const mensajeTexto =
                        registrarMensaje({
                            ...baseMensaje,
                            texto,
                        }) || { ...baseMensaje, texto };
                    agregarMensajeTexto(mensajeTexto);
                } catch (err) {
                    console.warn("No se pudo descifrar un mensaje:", err);
                    const li = crearContenedorMensaje(baseMensaje);
                    li.innerHTML = `
          <div class="texto">[No se pudo descifrar el mensaje]</div>
          <div class="hora">${m.fecha}</div>
        `;
                    renderReacciones(li, baseMensaje);
                    lista.appendChild(li);
                }
            }

            lista.scrollTop = lista.scrollHeight;
        }

        // ---------- CONFIGURAR CLAVE DE CIFRADO ----------

        function solicitarAccesoAlServidor() {
            mensajeLogin.textContent = "Verificando clave...";
            mensajeLogin.style.color = "#4b5563";
            socket.emit("auth", { password: CLAVE_UNICA });
        }

        btnClave.onclick = () => {
            const passwordCifrado = claveCifradoInput.value.trim();

            if (passwordCifrado !== CLAVE_UNICA) {
                mensajeLogin.textContent = 'Clave incorrecta.';
                mensajeLogin.style.color = "salmon";
                input.disabled = true;
                btn.disabled = true;
                claveValidaIngresada = false;

                // Ocultar logout si existe
                if (btnLogout) btnLogout.style.display = "none";
                return;
            }

            claveValidaIngresada = true;
            solicitarAccesoAlServidor();
        };

        claveCifradoInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                btnClave.click();
            }
        });

        socket.on("auth-ok", async () => {
            try {
                cryptoKey = await deriveKeyFromPassword(CLAVE_UNICA);
                mensajeLogin.textContent = "Clave de cifrado lista.";
                mensajeLogin.style.color = "#16a34a";
                input.disabled = false;
                btn.disabled = false;
                if (btnImagen) btnImagen.disabled = false;
                estado.textContent = "Conectado (clave configurada)";

                document.getElementById("login").classList.add("oculto");

                guardarPass(CLAVE_UNICA);

                // Mostrar logout SOLO cuando ya est√°s autenticado
                if (btnLogout) btnLogout.style.display = "inline-flex";

                procesarBufferSiClaveLista();
            } catch (err) {
                console.error(err);
                mensajeLogin.textContent = "Error derivando clave de cifrado.";
                mensajeLogin.style.color = "salmon";
            }
        });

        socket.on("auth-denegado", () => {
            claveValidaIngresada = false;
            cryptoKey = null;
            mensajeLogin.textContent = 'Clave incorrecta.';
            mensajeLogin.style.color = "salmon";
            estado.textContent = "Clave incorrecta";
            document.getElementById("login").classList.remove("oculto");
            input.disabled = true;
            btn.disabled = true;
            if (btnImagen) btnImagen.disabled = true;
            setEstadoSubida("");

            // Ocultar logout al quedar no autorizado
            if (btnLogout) btnLogout.style.display = "none";
        });

        // ---------- HISTORIAL Y MENSAJES ----------

        socket.on("identidad", (data) => {
            miAutorId = data.autor;
        });

        socket.on("historial", (mensajesCifrados) => {
            lista.innerHTML = "";
            ultimoAutor = null;
            mensajesRenderizados.clear();
            bufferMensajesPendientes.push(...mensajesCifrados);
            procesarBufferSiClaveLista();
        });

        socket.on("mensaje", (m) => {
            bufferMensajesPendientes.push(m);
            procesarBufferSiClaveLista();
        });

        socket.on("reaccion-actualizada", ({ mensajeId, reacciones }) => {
            if (!mensajeId) return;
            const reacc = asegurarReacciones({ reacciones });
            const existente = mensajesRenderizados.get(mensajeId);
            if (existente) {
                existente.reacciones = reacc;
                mensajesRenderizados.set(mensajeId, existente);
            } else {
                mensajesRenderizados.set(mensajeId, { id: mensajeId, reacciones: reacc });
            }

            const li = lista.querySelector(`li[data-mid=\"${mensajeId}\"]`);
            if (li) {
                renderReacciones(li, { id: mensajeId, reacciones: reacc });
            }
        });

        // ---------- ENV√çO DE MENSAJES ----------

        function setEstadoSubida(texto, color = "#6b7280") {
            if (!estadoSubida) return;
            estadoSubida.textContent = texto || "";
            estadoSubida.style.color = color;
        }

        async function manejarArchivoImagen(file) {
            if (!file) return;

            if (!claveValidaIngresada) {
                setEstadoSubida("Primero ingresa la clave correcta.", "salmon");
                return;
            }

            if (!MIME_PERMITIDOS.includes(file.type)) {
                setEstadoSubida("Solo se permiten PNG o JPG.", "salmon");
                return;
            }

            if (file.size > MAX_UPLOAD_BYTES) {
                setEstadoSubida("Imagen demasiado grande (max 10MB).", "salmon");
                return;
            }

            try {
                setEstadoSubida("Subiendo imagen...", "#2563eb");

                const formData = new FormData();
                formData.append("imagen", file);
                formData.append("autor", miAutorId || "anon");

                const resp = await fetch("/upload", {
                    method: "POST",
                    body: formData,
                    headers: { "x-chat-key": CLAVE_UNICA },
                });

                if (!resp.ok) {
                    const errText = await resp.text();
                    throw new Error(errText || "Error subiendo imagen");
                }

                await resp.json();
                setEstadoSubida("Imagen enviada.", "#16a34a");
                setTimeout(() => setEstadoSubida(""), 2000);
            } catch (err) {
                console.error("Error subiendo imagen:", err);
                setEstadoSubida("Error subiendo imagen.", "salmon");
            } finally {
                if (fileInput) fileInput.value = "";
            }
        }

        if (btnImagen && fileInput) {
            btnImagen.addEventListener("click", () => {
                if (btnImagen.disabled) return;
                fileInput.click();
            });

            fileInput.addEventListener("change", () => {
                const file = fileInput.files?.[0];
                if (file) manejarArchivoImagen(file);
            });
        }

        btn.onclick = async () => {
            if (!cryptoKey) {
                alert("Primero debes configurar la clave de cifrado.");
                return;
            }

            const texto = input.value.trim();
            if (!texto) return;

            try {
                const { cipherTextBase64, ivBase64 } = await encryptText(texto);

                const data = {
                    cipherText: cipherTextBase64,
                    iv: ivBase64,
                    fecha: new Date().toLocaleTimeString(),
                };

                socket.emit("mensaje", data);
                input.value = "";
            } catch (err) {
                console.error("Error cifrando mensaje:", err);
                alert("Error cifrando mensaje.");
            }
        };

        input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                btn.click();
            }
        });

        // ---------- ESTADO DE CONEXI√ìN ----------

        socket.on("connect", () => {
            console.log("Conectado al servidor de sockets");
            estado.textContent = cryptoKey
                ? "Conectado (clave configurada)"
                : "Conectado (esperando clave de cifrado)";

            if (btnImagen) btnImagen.disabled = !cryptoKey;

            // NO mostramos logout aqu√≠; se mostrar√° solo tras auth-ok
            if (btnLogout) btnLogout.style.display = cryptoKey ? "inline-flex" : "none";

            if (claveValidaIngresada && claveCifradoInput.value.trim() === CLAVE_UNICA) {
                solicitarAccesoAlServidor();
            }
        });

        socket.on("disconnect", () => {
            console.log("Desconectado del servidor de sockets");
            estado.textContent = "Desconectado";
            input.disabled = true;
            btn.disabled = true;
            if (btnImagen) btnImagen.disabled = true;
            setEstadoSubida("");

            // Al desconectarse, ocultar logout
            if (btnLogout) btnLogout.style.display = "none";
        });

        // ---------- LOG OUT ----------
        async function logout() {
            if (!btnLogout) return;

            btnLogout.disabled = true;
            const originalText = btnLogout.textContent;
            btnLogout.textContent = "Saliendo...";

            try {
                await fetch("/logout", {
                    method: "POST",
                    credentials: "include",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ reason: "user_logout" }),
                });
            } catch (e) {
                console.warn("Logout server request failed:", e);
            } finally {
                // Ocultar logout inmediatamente (antes de redirigir)
                btnLogout.style.display = "none";

                // Limpiar almacenamiento local
                try { localStorage.removeItem(PASS_STORAGE_KEY); } catch (e) { }
                try { sessionStorage.clear(); } catch (e) { }

                // Resetear estado de UI
                claveValidaIngresada = false;
                cryptoKey = null;
                ultimoAutor = null;
                bufferMensajesPendientes = [];
                input.disabled = true;
                btn.disabled = true;
                if (btnImagen) btnImagen.disabled = true;
                setEstadoSubida("");

                // Mostrar barra de login de nuevo por si no redirige
                const loginBar = document.getElementById("login");
                if (loginBar) loginBar.classList.remove("oculto");

                // Desconectar socket
                try { socket.disconnect(); } catch (e) { }

                // Redirigir
                window.location.replace("/");

                // fallback por si el navegador cancela replace en alg√∫n caso raro
                btnLogout.disabled = false;
                btnLogout.textContent = originalText;
            }
        }

        if (btnLogout) {
            btnLogout.addEventListener("click", logout);
        }

        // ---------- DARK MODE ----------
        const THEME_KEY = "chat_theme_v1";

        function setTheme(theme) {
            document.documentElement.setAttribute("data-theme", theme);
            try { localStorage.setItem(THEME_KEY, theme); } catch (e) { }

            // Icono: luna en light, sol en dark
            if (themeBtn) {
                const icon = themeBtn.querySelector(".theme-icon");
                if (icon) icon.textContent = theme === "dark" ? "‚òÄÔ∏é" : "‚òæ";
                themeBtn.title = theme === "dark" ? "Modo claro" : "Modo oscuro";
            }
        }

        function getInitialTheme() {
            try {
                const saved = localStorage.getItem(THEME_KEY);
                if (saved === "light" || saved === "dark") return saved;
            } catch (e) { }

            return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                ? "dark"
                : "light";
        }

        // Aplicar theme al cargar
        setTheme(getInitialTheme());

        // Click toggle
        if (themeBtn) {
            themeBtn.addEventListener("click", () => {
                const current = document.documentElement.getAttribute("data-theme") || "light";
                const next = current === "dark" ? "light" : "dark";
                setTheme(next);
            });
        }

        // ---------- AUTOCARGA DE PASSWORD GUARDADA ----------
        (function init() {
            const passGuardada = cargarPass();
            if (passGuardada === CLAVE_UNICA) {
                claveCifradoInput.value = passGuardada;
                mensajeLogin.textContent = "Pulsa Enter";
                mensajeLogin.style.color = "#4b5563";
                claveValidaIngresada = true;
            } else if (passGuardada) {
                localStorage.removeItem(PASS_STORAGE_KEY);
            }
        })();
    </script>


</body>

</html>